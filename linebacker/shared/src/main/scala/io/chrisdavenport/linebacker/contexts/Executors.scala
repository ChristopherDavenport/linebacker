package io.chrisdavenport.linebacker.contexts

import cats.effect.{Resource, Sync}
import cats.implicits._
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.{ExecutorService, Executors => E, ForkJoinPool, ThreadFactory}

object Executors {

  import unsafe._

  /**
   * Recommended Pool For Non-CPU Load Blocking.
   * For example in a situation where you are
   * transitioning off a CPU loaded task and onto
   * a Hikari pool, you may want to back the
   * resource with the same number of threads.
   */
  def fixedPool[F[_]: Sync](n: Int) =
    executorServiceResource(fixedPoolExecutorUnsafe(n))

  /**
   * Constructs an unbound thread pool that will create
   * a new thread for each submitted job. This is useful
   * if you have a construct that is blocking but
   * self-manages the number of threads you can consume.
   */
  def unbound[F[_]: Sync]: Resource[F, ExecutorService] =
    executorServiceResource(unboundExecutorUnsafe)

  /**
   * A work stealing pool is often a useful blocking
   * pool for CPU bound blocking work that you want
   * to transition off the pool that is handling your
   * requests, generally set to the number of processors
   * to maximize the processor use. Perhaps subtracting
   * 1 as to maximize the other pool for handling
   * requests or other work.
   */
  def workStealingPool[F[_]: Sync](n: Int) =
    executorServiceResource(workStealingPoolUnsafe(n))

  /**
   * Default Pool For Scala, optimized for forked work and then returning to a
   * main pool, generally ideal for your main event loop.
   */
  def forkJoinPool[F[_]: Sync](n: Int) =
    executorServiceResource(forkJoinPoolUnsafe(n))

  private def executorServiceResource[F[_]: Sync](
      f: F[ExecutorService]): Resource[F, ExecutorService] =
    Resource.make[F, ExecutorService](f)(es => Sync[F].delay(es.shutdownNow).void)

  object unsafe {
    def unboundExecutorUnsafe[F[_]: Sync]: F[ExecutorService] = Sync[F].delay {
      E.newCachedThreadPool(new ThreadFactory {
        private val counter = new AtomicLong(0L)

        def newThread(r: Runnable) = {
          val th = new Thread(r)
          th.setName("linebacker-thread-" + counter.getAndIncrement.toString)
          th.setDaemon(true)
          th
        }
      })
    }
    def fixedPoolExecutorUnsafe[F[_]: Sync](n: Int): F[ExecutorService] =
      Sync[F].delay { E.newFixedThreadPool(n) }
    def workStealingPoolUnsafe[F[_]: Sync](n: Int): F[ExecutorService] =
      Sync[F].delay(E.newWorkStealingPool(n))
    def forkJoinPoolUnsafe[F[_]: Sync](n: Int): F[ExecutorService] =
      Sync[F].delay(new ForkJoinPool(n))
  }
}
